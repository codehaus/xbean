/**
 *
 * Copyright 2005 the original author or authors.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.xbean.spring.generator;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Iterator;

/**
 * @author Dain Sundstrom
 * @version $Id$
 * @since 1.0
 */
public class XsdGenerator implements GeneratorPlugin {
    private final File destFile;

    public XsdGenerator(File destFile) {
        this.destFile = destFile;
    }

    public void generate(NamespaceMapping namespaceMapping) throws IOException {
        // TODO can only handle 1 schema document so far...
        File file = destFile;
        System.out.println("Generating XSD file: " + file + " for namespace: " + namespaceMapping.getNamespace());
        PrintWriter out = new PrintWriter(new FileWriter(file));
        try {
            generateSchema(out, namespaceMapping);
        } finally {
            out.close();
        }
    }

    private void generateSchema(PrintWriter out, NamespaceMapping namespaceMapping) {
        out.println("<?xml version='1.0'?>");
        out.println("<!-- NOTE: this file is autogenerated by XBeans -->");
        out.println();
        out.println("<xs:schema elementFormDefault='qualified'");
        out.println("           targetNamespace='" + namespaceMapping.getNamespace() + "'");
        out.println("           xmlns:xs='http://www.w3.org/2001/XMLSchema'");
        out.println("           xmlns:tns='" + namespaceMapping.getNamespace() + "'>");

        for (Iterator iter = namespaceMapping.getElements().iterator(); iter.hasNext();) {
            ElementMapping element = (ElementMapping) iter.next();
            generateElementMapping(out, namespaceMapping, element);
        }

        out.println();
        out.println("</xs:schema>");
    }

    private void generateElementMapping(PrintWriter out, NamespaceMapping namespaceMapping, ElementMapping element) {
        out.println();
        out.println("  <!-- element for type: " + element.getClassName() + " -->");

        String localName = element.getElementName();

        out.println("  <xs:element name='" + localName + "'>");
        out.println("    <xs:complexType>");

        int complexCount = 0;
        for (Iterator iterator = element.getAttributes().iterator(); iterator.hasNext();) {
            AttributeMapping attributeMapping = (AttributeMapping) iterator.next();
            if (!Utils.isSimpleType(attributeMapping)) {
                complexCount++;
            }
        }
        if (complexCount > 0) {
            out.println("      <xs:sequence>");
            for (Iterator iterator = element.getAttributes().iterator(); iterator.hasNext();) {
                AttributeMapping attributeMapping = (AttributeMapping) iterator.next();
                if (!Utils.isSimpleType(attributeMapping)) {
                    generateElementMappingComplexProperty(out, namespaceMapping, attributeMapping);
                }
            }
            out.println("      </xs:sequence>");
        }

        for (Iterator iterator = element.getAttributes().iterator(); iterator.hasNext();) {
            AttributeMapping attributeMapping = (AttributeMapping) iterator.next();
            if (Utils.isSimpleType(attributeMapping)) {
                generateElementMappingSimpleProperty(out, attributeMapping);
            }
        }
        out.println("    </xs:complexType>");
        out.println("  </xs:element>");
        out.println();
    }

    private void generateElementMappingSimpleProperty(PrintWriter out, AttributeMapping attributeMapping) {
        out.println("      <xs:attribute name='" + attributeMapping.getAttributeName() + "' type='" + Utils.getXsdType(attributeMapping) + "'/>");
    }

    private void generateElementMappingComplexProperty(PrintWriter out, NamespaceMapping namespaceMapping, AttributeMapping attributeMapping) {
        out.println("      <xs:element name='" + attributeMapping.getAttributeName() + "' minOccurs='0' maxOccurs='1'>");
        // Check if this is an array of known elements
        boolean found = false;
        if (attributeMapping.isArray()) {
            for (Iterator iter = namespaceMapping.getElements().iterator(); iter.hasNext();) {
                ElementMapping elem = (ElementMapping) iter.next();
                if (elem.getClassName().equals(attributeMapping.getArrayType())) {
                    out.println("        <xs:complexType><xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:element ref='tns:" + elem.getElementName() + "'/></xs:sequence></xs:complexType>");
                    found = true;
                    break;
                }
            }

        }
        // Else, use an xs:any to allow extension
        if (!found) {
            out.println("        <xs:complexType><xs:sequence><xs:any/></xs:sequence></xs:complexType>");
        }
        out.println("      </xs:element>");
    }

}
